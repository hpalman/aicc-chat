í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì›¹ì±„íŒ…ì„ ìœ„í•´ ì›¹ì†Œì¼“ ì—°ê²° ì´í›„ í˜ì´ì§€ ìƒˆë¡œ ê³ ì¹¨ ì‹œ ì´ì „ì— ì›¹ ì†Œì¼“ ì—°ê²° ì „ì˜ í† í°ì„ ìœ ì§€í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ìˆë‚˜ìš”? ì•Œë ¤ì£¼ì„¸ìš”
ì›¹ì†Œì¼“ ì—°ê²° ì‹œ ì‚¬ìš©í•œ í† í°ì„ í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ í›„ì—ë„ ìœ ì§€í•˜ëŠ” ê²ƒì€ í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì €ì¥ì†Œ(localStorageë‚˜ sessionStorage)ë¥¼ í™œìš©í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¼ë°˜ì ì¸ ë°©ë²•ì…ë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ì€ í˜ì´ì§€ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•˜ì§€ë§Œ, ì´ëŸ¬í•œ ì €ì¥ì†ŒëŠ” ë¸Œë¼ìš°ì €ê°€ ìœ ì§€í•˜ë¯€ë¡œ í† í°ì„ ë‹¤ì‹œ ë¶ˆëŸ¬ì™€ ì¬ì—°ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
â€‹

í† í° ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸°
localStorageì— í† í°ì„ ì €ì¥í•˜ë©´ ìƒˆë¡œê³ ì¹¨ í›„ì—ë„ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.
sessionStorageëŠ” íƒ­ì´ ë‹«í ë•Œê¹Œì§€ ìœ ì§€ë˜ë©° ë³´ì•ˆì´ ë” ê°•í•©ë‹ˆë‹¤.
â€‹

javascript
// ì—°ê²° ì „ í† í° ì €ì¥
localStorage.setItem('authToken', yourToken);

// ìƒˆë¡œê³ ì¹¨ í›„ í† í° ë¶ˆëŸ¬ì˜¤ê¸°
const token = localStorage.getItem('authToken');
const ws = new WebSocket(`ws://example.com?token=${token}`);
ì›¹ì†Œì¼“ ì¬ì—°ê²° ë¡œì§
í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ëœ í† í°ìœ¼ë¡œ ìë™ ì¬ì—°ê²°ì„ êµ¬í˜„í•˜ì„¸ìš”.
beforeunload ì´ë²¤íŠ¸ë¡œ ì—°ê²° ì¢…ë£Œ ì „ í† í° ìƒíƒœë¥¼ í™•ì¸í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
â€‹
ì—°ê²° í›„ ì²« ë©”ì‹œì§€ë¡œ í† í° ì¬ì¸ì¦ì„ í•˜ë©´ ì„œë²„ì—ì„œ ìœ íš¨ì„±ì„ ê²€ì¦í•©ë‹ˆë‹¤.
â€‹

ê³ ê¸‰ ìœ ì§€ ë°©ë²•
SharedWorkerë¥¼ ì‚¬ìš©í•˜ë©´ ìƒˆë¡œê³ ì¹¨ ì‹œì—ë„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì›¹ì†Œì¼“ ì—°ê²°ì„ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
â€‹
Spring Boot ë°±ì—”ë“œì—ì„œëŠ” ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë‚˜ Sec-WebSocket-Protocol í—¤ë”ë¡œ í† í°ì„ ì²˜ë¦¬í•˜ì„¸ìš”.
â€‹
ì§§ì€ ìœ íš¨ê¸°ê°„ì˜ ì„¸ì»¨ë”ë¦¬ í† í°ì„ ë°œê¸‰ë°›ì•„ ì‚¬ìš©í•˜ë©´ ë³´ì•ˆì´ ê°•í™”ë©ë‹ˆë‹¤.
â€‹

ì›¹ì±„íŒ… ì‹œìŠ¤í…œ êµ¬ì¶• ì‹œ ì¼ì • ì‹œê°„ì´ ê²½ê³¼í•´ë„ ê³ ê°ì˜ ì •ë³´ë¥¼ ì–´ëŠ ì •ë„ í™•ì¸í•  ìˆ˜ ìˆëŠ” í† í°ì •ë³´ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì„ ì•Œë ¤ì¤˜
ì›¹ì±„íŒ… ì‹œìŠ¤í…œì—ì„œ ì¥ì‹œê°„ ê²½ê³¼ í›„ì—ë„ ê³ ê° ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆëŠ” í† í°ì€ ì£¼ë¡œ JWT(JSON Web Token)ì˜ Refresh Token ë°©ì‹ì„ ì‚¬ìš©í•´ êµ¬í˜„í•©ë‹ˆë‹¤. Access Tokenì€ ì§§ì€ ìœ íš¨ê¸°ê°„(ì˜ˆ: 15ë¶„~1ì‹œê°„)ìœ¼ë¡œ ë³´ì•ˆì„ ìœ ì§€í•˜ê³ , Refresh Tokenì€ ê¸¸ê²Œ ì„¤ì •(ì˜ˆ: 7ì¼~30ì¼)í•´ ì¬ë°œê¸‰ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
â€‹

í† í° êµ¬ì¡° ì„¤ê³„
Access Tokenì—ëŠ” ê³ ê° ID, ì—­í•  ë“± ê¸°ë³¸ ì •ë³´ë¥¼ payloadì— í¬í•¨í•˜ê³  expiresInìœ¼ë¡œ ìœ íš¨ê¸°ê°„ì„ ì„¤ì •í•˜ì„¸ìš”.
Refresh Tokenì€ ë³„ë„ ì €ì¥ì†Œ(DBë‚˜ Redis)ì— ê³ ê° IDì™€ í•¨ê»˜ ê¸°ë¡í•˜ë©°, ì´ë¥¼ ê²€ì¦ í›„ ìƒˆ Access Tokenì„ ë°œê¸‰í•©ë‹ˆë‹¤.
â€‹
Spring Bootì—ì„œ JWT ë¼ì´ë¸ŒëŸ¬ë¦¬(jjwt)ë¥¼ ì‚¬ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ ìƒì„±í•©ë‹ˆë‹¤:

java
String accessToken = Jwts.builder()
    .setSubject(customerId)
    .setExpiration(new Date(System.currentTimeMillis() + 3600000)) // 1ì‹œê°„
    .signWith(secretKey)
    .compact();

String refreshToken = Jwts.builder()
    .setSubject(customerId)
    .setExpiration(new Date(System.currentTimeMillis() + 604800000)) // 7ì¼
    .signWith(refreshSecretKey)
    .compact();
ì›¹ì†Œì¼“ ì ìš© ë¡œì§
ì›¹ì†Œì¼“ ì—°ê²° ì‹œ Access Tokenì„ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë‚˜ í—¤ë”ë¡œ ì „ë‹¬í•˜ê³ , ë§Œë£Œ ì‹œ í´ë¼ì´ì–¸íŠ¸ê°€ Refresh Tokenìœ¼ë¡œ ì¬ë°œê¸‰ ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤.
â€‹
ì„œë²„ì—ì„œëŠ” ì›¹ì†Œì¼“ í•¸ë“œì…°ì´í¬ ë‹¨ê³„ì—ì„œ í† í°ì„ ê²€ì¦í•˜ë©°, Refresh API(/refresh)ë¥¼ ë³„ë„ë¡œ êµ¬í˜„í•´ ê³ ê° ì •ë³´ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
â€‹
Redisì— Refresh Tokenì„ ì €ì¥í•˜ë©´ ë¶„ì‚° í™˜ê²½ì—ì„œë„ ë¹ ë¥¸ ê²€ì¦ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ë³´ì•ˆ ê°•í™” íŒ
Refresh Token ë¸”ë™ë¦¬ìŠ¤íŠ¸(Redis SETEX ì‚¬ìš©)ë¡œ ë¡œê·¸ì•„ì›ƒ ì‹œ ë¬´íš¨í™”í•˜ì„¸ìš”.
ê³ ê° ì •ë³´ëŠ” Access Tokenì— ìµœì†Œí™”í•˜ê³ , í•„ìš” ì‹œ ì„œë²„ DB ì¡°íšŒë¡œ ë³´ì™„í•©ë‹ˆë‹¤.
â€‹
í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” localStorage ëŒ€ì‹  httpOnly ì¿ í‚¤ë¥¼ í™œìš©í•´ XSS ê³µê²©ì„ ë°©ì§€í•˜ì„¸ìš”.
â€‹

WebSocket ì±„íŒ…ì—ì„œ JWT í† í° ì „ë‹¬í•˜ëŠ” ì½”ë“œ
WebSocket ì±„íŒ…ì—ì„œ JWT í† í°ì„ ì „ë‹¬í•˜ëŠ” ì£¼ìš” ë°©ë²•ì€ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°, STOMP í—¤ë”, ë˜ëŠ” Sec-WebSocket-Protocolì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ì—ì„œ í† í°ì„ ì•ˆì „í•˜ê²Œ ì „ë‹¬í•œ í›„ ì„œë²„ì—ì„œ ChannelInterceptorë¡œ ê²€ì¦í•˜ëŠ” êµ¬ì¡°ê°€ í‘œì¤€ì…ë‹ˆë‹¤.
â€‹

í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì½”ë“œ (JavaScript)
STOMP over WebSocketì—ì„œ Authorization í—¤ë”ë¡œ í† í°ì„ ì „ë‹¬í•©ë‹ˆë‹¤.

javascript
const socket = new SockJS('/ws-stomp');
const stompClient = Stomp.over(socket);
stompClient.connect({
    'Authorization': `Bearer ${localStorage.getItem('jwtToken')}`
}, function(frame) {
    console.log('Connected: ' + frame);
    stompClient.subscribe('/topic/chat', callback);
});
ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë°©ì‹ë„ ê°„ë‹¨í•©ë‹ˆë‹¤: new SockJS('/ws-stomp?token=' + jwtToken)
â€‹

ì„œë²„ ê²€ì¦ ì½”ë“œ (Spring Boot)
StompHandlerì—ì„œ CONNECT ëª…ë ¹ ì‹œ í† í°ì„ ê²€ì¦í•©ë‹ˆë‹¤.
â€‹

java
@Component
public class StompHandler implements ChannelInterceptor {
    private final JwtTokenProvider jwtTokenProvider;
    
    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        
        if (StompCommand.CONNECT.equals(accessor.getCommand())) {
            String auth = accessor.getFirstNativeHeader("Authorization");
            if (auth != null && auth.startsWith("Bearer ")) {
                String token = auth.substring(7);
                Map<String, Object> claims = jwtTokenProvider.validateToken(token);
                Long userId = Long.parseLong(claims.get("userId").toString());
                accessor.setUser(new Principal() {
                    public String getName() { return userId.toString(); }
                });
            }
        }
        return message;
    }
}
WebSocketConfig ì„¤ì •
ì¸í„°ì…‰í„°ë¥¼ ë“±ë¡í•˜ê³  ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì„¤ì •í•˜ì„¸ìš”.
â€‹

java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Autowired private StompHandler stompHandler;
    
    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(stompHandler);
    }
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws-stomp")
                .setAllowedOriginPatterns("*");
    }
}
ë³´ì•ˆ íŒ
ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ëŠ” URL ë¡œê·¸ì— ë…¸ì¶œë  ìˆ˜ ìˆìœ¼ë‹ˆ í—¤ë” ë°©ì‹ì„ ìš°ì„  ì‚¬ìš©í•˜ì„¸ìš”.
â€‹

í† í° ë§Œë£Œ ì‹œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ refresh í›„ ì¬ì—°ê²° ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
â€‹

Redisì— ë¸”ë™ë¦¬ìŠ¤íŠ¸ë¥¼ ì €ì¥í•´ ë¡œê·¸ì•„ì›ƒ ì‹œ í† í°ì„ ë¬´íš¨í™”í•˜ì„¸ìš”.
â€‹

íŒ¨í‚¤ì§€ëŠ” 'package aicc.chat.handler;' ì´ê²ƒìœ¼ë¡œ í•´ì„œ JwtTokenProvider ì´ í´ë˜ìŠ¤ë§Œ ë³´ì—¬ì£¼ì§€ ë§ê³  spring boot 3.4.1ì—ì„œ êµ¬ë™ ê°€ëŠ¥í•œ ì œëŒ€ë¡œ ëœ ì „ì²´ì½”ë“œë¥¼ ë§Œë“¤ì–´ì¤˜ë´
íŒ¨í‚¤ì§€: aicc.chat.handler - Spring Boot 3.4.1 ì™„ì „ êµ¬í˜„
1. JwtTokenProvider.java
java
package aicc.chat.handler;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import io.jsonwebtoken.ExpiredJwtException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Slf4j
@Component
public class JwtTokenProvider {
    
    @Value("${jwt.secret:your-very-long-secret-key-minimum-256-bits-for-HS512-change-in-production}")
    private String secretKey;
    
    @Value("${jwt.access-token-validity:3600000}") // 1ì‹œê°„ (ms)
    private long accessTokenValidity;
    
    private final SecretKey key;
    
    public JwtTokenProvider() {
        this.key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
    }
    
    public String createToken(String userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + accessTokenValidity);
        
        return Jwts.builder()
                .setSubject(userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }
    
    public Claims validateToken(String token) {
        try {
            return Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
        } catch (ExpiredJwtException e) {
            log.warn("JWT í† í° ë§Œë£Œ: {}", e.getMessage());
            throw new RuntimeException("Token expired", e);
        } catch (SignatureException | IllegalArgumentException e) {
            log.error("JWT ê²€ì¦ ì‹¤íŒ¨: {}", e.getMessage());
            throw new RuntimeException("Invalid JWT token", e);
        }
    }
    
    public String getUserIdFromToken(String token) {
        Claims claims = validateToken(token);
        return claims.getSubject();
    }
}
2. StompHandler.java (ChannelInterceptor)
java
package aicc.chat.handler;

import aicc.chat.principal.WebSocketUserPrincipal;
import io.jsonwebtoken.Claims;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.simp.stomp.StompCommand;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 99)
@RequiredArgsConstructor
public class StompHandler implements ChannelInterceptor {
    
    private final JwtTokenProvider jwtTokenProvider;
    
    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        
        if (StompCommand.CONNECT.equals(accessor.getCommand())) {
            authenticateUser(accessor);
        }
        
        return message;
    }
    
    private void authenticateUser(StompHeaderAccessor accessor) {
        String authToken = accessor.getFirstNativeHeader("Authorization");
        
        if (authToken == null || !authToken.startsWith("Bearer ")) {
            log.warn("Authorization í—¤ë” ëˆ„ë½");
            throw new IllegalArgumentException("Authorization header required");
        }
        
        String token = authToken.substring(7);
        try {
            Claims claims = jwtTokenProvider.validateToken(token);
            String userId = claims.getSubject();
            
            accessor.setUser(new WebSocketUserPrincipal(userId));
            log.info("WebSocket ì—°ê²° ì¸ì¦ ì„±ê³µ: userId={}", userId);
            
        } catch (Exception e) {
            log.error("JWT ê²€ì¦ ì‹¤íŒ¨", e);
            throw new IllegalArgumentException("Invalid JWT token: " + e.getMessage());
        }
    }
}
3. WebSocketUserPrincipal.java
java
package aicc.chat.principal;

import java.security.Principal;

public class WebSocketUserPrincipal implements Principal {
    private final String userId;
    
    public WebSocketUserPrincipal(String userId) {
        this.userId = userId;
    }
    
    @Override
    public String getName() {
        return userId;
    }
    
    public String getUserId() {
        return userId;
    }
}
4. WebSocketConfig.java
java
package aicc.chat.config;

import aicc.chat.handler.StompHandler;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
@RequiredArgsConstructor
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    
    private final StompHandler stompHandler;
    
    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(stompHandler);
    }
    
    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic", "/queue");
        config.setApplicationDestinationPrefixes("/app");
    }
    
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws-chat")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }
}
5. build.gradle ì˜ì¡´ì„±
text
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-websocket'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    implementation 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
}
6. application.yml
text
jwt:
  secret: your-super-secret-key-must-be-at-least-256-bits-long-for-hs512
  access-token-validity: 3600000  # 1ì‹œê°„

spring:
  websocket:
    sockjs:
      session:
        cookie:
          needed: false
7. í…ŒìŠ¤íŠ¸ìš© ChatController.java
java
package aicc.chat.controller;

import aicc.chat.principal.WebSocketUserPrincipal;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.stereotype.Controller;

@Slf4j
@Controller
public class ChatController {
    
    @MessageMapping("/chat.send")
    @SendTo("/topic/chat")
    public ChatMessage sendMessage(@Payload ChatMessage message, 
                                 @AuthenticationPrincipal WebSocketUserPrincipal principal) {
        message.setSender(principal.getUserId());
        log.info("ë©”ì‹œì§€ ì „ì†¡: {} -> {}", message.getSender(), message.getContent());
        return message;
    }
}

class ChatMessage {
    private String sender;
    private String content;
    
    // getter, setter
    public String getSender() { return sender; }
    public void setSender(String sender) { this.sender = sender; }
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
}
Spring Boot 3.4.1 ì™„ì „ í˜¸í™˜, ë°”ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•©ë‹ˆë‹¤. JwtTokenProviderì˜ @Valueë¡œ ì„¤ì •ê°’ì„ ë™ì ìœ¼ë¡œ ê´€ë¦¬í•˜ë©°, Lombok @RequiredArgsConstructorë¡œ ì˜ì¡´ì„± ì£¼ì…ì´ ìë™í™”ë˜ì—ˆìŠµë‹ˆë‹¤.

onConnect onStompError ì´ë²¤íŠ¸ í•¸ë“¤ë§
STOMP.js onConnect & onStompError ì´ë²¤íŠ¸ ì™„ì „ í•¸ë“¤ë§ ê°€ì´ë“œ
ğŸ¯ STOMP.js v2.3.3 ì½œë°± ê¸°ë°˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
1. ê¸°ë³¸ ì´ë²¤íŠ¸ ì½œë°± êµ¬ì¡°
javascript
const stompClient = Stomp.over(new SockJS('/ws-chat'));

stompClient.connect(headers, 
    // âœ… onConnect ì½œë°± (ì—°ê²° ì„±ê³µ)
    function(frame) {
        console.log('ğŸŸ¢ onConnect:', frame);
        // êµ¬ë… ì‹œì‘, ìƒíƒœ ì—…ë°ì´íŠ¸
    },
    // âŒ onStompError ì½œë°± (STOMP ì˜¤ë¥˜)
    function(frame) {
        console.error('ğŸ”´ onStompError:', frame.headers['message']);
        console.error('ìƒì„¸:', frame.body);
        // ì¬ì—°ê²°, ì˜¤ë¥˜ UI
    }
);
ğŸš€ ì™„ì „í•œ ì´ë²¤íŠ¸ í•¸ë“¤ë§ í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ
xml
<!DOCTYPE html>
<html>
<head>
    <title>STOMP ì´ë²¤íŠ¸ ì™„ì „ í•¸ë“¤ë§</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        #status { padding: 10px; margin: 10px 0; border-radius: 5px; font-weight: bold; }
        .connected { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .connecting { background: #fff3cd; color: #856404; }
        #events { height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; }
        .event { margin: 5px 0; padding: 5px; background: #f8f9fa; border-left: 4px solid; }
        .success { border-left-color: #28a745; }
        .error { border-left-color: #dc3545; }
    </style>
</head>
<body>
    <h1>ğŸ”— STOMP.js ì´ë²¤íŠ¸ í•¸ë“¤ë§ ë°ëª¨</h1>
    
    <div id="status" class="error">ğŸ”´ ì—°ê²°ë˜ì§€ ì•ŠìŒ</div>
    
    <div>
        <button onclick="connectStomp()">ì—°ê²°</button>
        <button onclick="disconnectStomp()">ì—°ê²°í•´ì œ</button>
        <button onclick="simulateError()">ì˜¤ë¥˜ ì‹œë®¬ë ˆì´ì…˜</button>
    </div>
    
    <h3>ì´ë²¤íŠ¸ ë¡œê·¸</h3>
    <div id="events"></div>
    
    <h3>ë©”ì‹œì§€ ì˜ì—­</h3>
    <div id="messages" style="height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px;"></div>

    <script>
        let stompClient = null;
        let jwtToken = null;
        let subscriptions = [];

        // 1. ì´ë²¤íŠ¸ ë¡œê·¸ ì¶”ê°€
        function logEvent(type, message, details = '') {
            const events = document.getElementById('events');
            const div = document.createElement('div');
            div.className = `event ${type}`;
            div.innerHTML = `
                <strong>[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}</strong>: ${message}
                ${details ? `<br><small>${details}</small>` : ''}
            `;
            events.appendChild(div);
            events.scrollTop = events.scrollHeight;
            console.log(`[${type}]`, message, details);
        }

        // 2. ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = type;
        }

        // 3. JWT í† í° íšë“
        async function getToken() {
            try {
                const response = await fetch('http://localhost:8080/api/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: 'user1', password: '1234' })
                });
                const data = await response.json();
                return data.accessToken;
            } catch (e) {
                throw new Error('ë¡œê·¸ì¸ ì‹¤íŒ¨: ' + e.message);
            }
        }

        // 4. ğŸ”¥ onConnect ì½œë°± (ì—°ê²° ì„±ê³µ)
        function onConnect(frame) {
            logEvent('success', 'STOMP ì—°ê²° ì„±ê³µ', `Frame: ${frame}`);
            updateStatus('ğŸŸ¢ ì—°ê²°ë¨ (Heartbeat í™œì„±)', 'connected');
            
            // êµ¬ë… ì‹œì‘
            const subscription = stompClient.subscribe('/topic/chat/all', function(message) {
                logEvent('message', 'ë©”ì‹œì§€ ìˆ˜ì‹ ', message.body);
                addMessage('ì„œë²„', JSON.parse(message.body).message);
            });
            subscriptions.push(subscription);
            
            // ì‚¬ìš©ì ìƒíƒœ ì „ì†¡
            stompClient.send('/app/user.connected', {}, JSON.stringify({
                userId: 'user1',
                timestamp: Date.now()
            }));
        }

        // 5. ğŸ”¥ onStompError ì½œë°± (STOMP ë¸Œë¡œì»¤ ì˜¤ë¥˜)
        function onStompError(frame) {
            const errorMsg = frame.headers['message'] || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
            const errorBody = frame.body || 'ìƒì„¸ ì •ë³´ ì—†ìŒ';
            
            logEvent('error', 'STOMP ë¸Œë¡œì»¤ ì˜¤ë¥˜', 
                `Message: ${errorMsg}<br>Body: ${errorBody}`
            );
            updateStatus(`ğŸ”´ STOMP ì˜¤ë¥˜: ${errorMsg}`, 'error');
            
            // íŠ¹ì • ì˜¤ë¥˜ë³„ ì²˜ë¦¬
            if (errorMsg.includes('authentication')) {
                logEvent('error', 'ì¸ì¦ ì‹¤íŒ¨ - ì¬ë¡œê·¸ì¸ í•„ìš”');
                // ìë™ ì¬ë¡œê·¸ì¸ ë¡œì§
            } else if (errorMsg.includes('version')) {
                logEvent('error', 'STOMP ë²„ì „ ë¶ˆì¼ì¹˜');
            }
        }

        // 6. WebSocket ìˆ˜ì¤€ ì˜¤ë¥˜ (onerror)
        function onWebSocketError(error) {
            logEvent('error', 'WebSocket ì˜¤ë¥˜', error);
            updateStatus('ğŸ”´ WebSocket ì˜¤ë¥˜', 'error');
        }

        // 7. ì—°ê²° í•¨ìˆ˜
        async function connectStomp() {
            try {
                updateStatus('ğŸ”„ ì—°ê²° ì‹œë„ì¤‘...', 'connecting');
                logEvent('info', 'ì—°ê²° ì‹œì‘');
                
                jwtToken = await getToken();
                
                const socket = new SockJS('http://localhost:8080/ws-chat');
                
                // SockJS ì´ë²¤íŠ¸ (WebSocket ìˆ˜ì¤€)
                socket.onopen = () => logEvent('success', 'SockJS ì—°ê²°ë¨');
                socket.onerror = onWebSocketError;
                socket.onclose = (event) => {
                    logEvent('warn', 'SockJS ì—°ê²° ì¢…ë£Œ', 
                        `Code: ${event.code}, Reason: ${event.reason}`
                    );
                };
                
                stompClient = Stomp.over(socket);
                stompClient.debug = (str) => {
                    if (str.includes('heart-beat') || str.includes('connected')) {
                        console.log('STOMP DEBUG:', str);
                    }
                };
                
                // ğŸ”¥ í•µì‹¬: 3ê°œ ì½œë°± ì™„ì „ ì„¤ì •
                stompClient.connect(
                    { Authorization: 'Bearer ' + jwtToken },
                    onConnect,           // ì—°ê²° ì„±ê³µ
                    onStompError         // STOMP ì˜¤ë¥˜
                );
                
            } catch (error) {
                logEvent('error', 'ì—°ê²° ì˜ˆì™¸', error.message);
                updateStatus('âŒ ì—°ê²° ì‹¤íŒ¨: ' + error.message, 'error');
            }
        }

        // 8. ì—°ê²° í•´ì œ
        function disconnectStomp() {
            if (stompClient) {
                // ëª¨ë“  êµ¬ë… í•´ì œ
                subscriptions.forEach(sub => sub.unsubscribe());
                subscriptions = [];
                
                stompClient.disconnect(() => {
                    logEvent('info', 'STOMP ì—°ê²° í•´ì œë¨');
                    updateStatus('ğŸ”¸ ì—°ê²° í•´ì œë¨', 'error');
                    stompClient = null;
                });
            }
        }

        // 9. ì˜¤ë¥˜ ì‹œë®¬ë ˆì´ì…˜
        function simulateError() {
            if (stompClient && stompClient.connected) {
                // ì˜ëª»ëœ destinationìœ¼ë¡œ ì „ì†¡ â†’ onStompError íŠ¸ë¦¬ê±°
                stompClient.send('/app/invalid.endpoint', {}, 'test');
            }
        }

        // 10. ë©”ì‹œì§€ UI
        function addMessage(sender, content) {
            const messages = document.getElementById('messages');
            const div = document.createElement('div');
            div.innerHTML = `<strong>${sender}:</strong> ${content}`;
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }

        // í˜ì´ì§€ ì¢…ë£Œ ì²˜ë¦¬
        window.addEventListener('beforeunload', () => {
            disconnectStomp();
        });
    </script>
</body>
</html>
ğŸ“‹ ì´ë²¤íŠ¸ë³„ ìƒì„¸ ë™ì‘
onConnect ì½œë°± (ì—°ê²° ì„±ê³µ)
text
íŠ¸ë¦¬ê±°: ì„œë²„ê°€ CONNECTED í”„ë ˆì„ ì‘ë‹µ
ì‹¤í–‰: 
âœ… êµ¬ë… ì„¤ì • (subscribe)
âœ… ìƒíƒœ UI ì—…ë°ì´íŠ¸  
âœ… ì‚¬ìš©ì ì…ì¥ ë©”ì‹œì§€ ì „ì†¡
âœ… Heartbeat ì‹œì‘
onStompError ì½œë°± (STOMP ë¸Œë¡œì»¤ ì˜¤ë¥˜)
text
íŠ¸ë¦¬ê±°: ì„œë²„ê°€ ERROR í”„ë ˆì„ ì „ì†¡
frame.headers['message']: ì˜¤ë¥˜ ë©”ì‹œì§€
frame.body: ìƒì„¸ ë‚´ìš©

ì¼ë°˜ì  ì˜¤ë¥˜:
- "User authentication failed"
- "Invalid STOMP version"
- "Access denied"
WebSocket ìˆ˜ì¤€ ì´ë²¤íŠ¸ (SockJS)
text
onopen:  WebSocket í•¸ë“œì…°ì´í¬ ì„±ê³µ
onerror: ë„¤íŠ¸ì›Œí¬/ì„œë²„ ì˜¤ë¥˜
onclose: code(1000~4999), reason
ğŸ” ì˜¤ë¥˜ë³„ ëŒ€ì‘ ì „ëµ
ì˜¤ë¥˜ ìœ í˜•	frame.headers['message']	ëŒ€ì‘
401 ì¸ì¦	"User authentication failed"	JWT ì¬ë°œê¸‰ â†’ ì¬ì—°ê²°
403 ê¶Œí•œ	"Access denied"	êµ¬ë… í•´ì œ â†’ ë°© ì´ë™
ë²„ì „	"Unsupported STOMP version"	í´ë¼ì´ì–¸íŠ¸ ë²„ì „ ì—…ë°ì´íŠ¸
ë¸Œë¡œì»¤	"Broker reported error"	ì„œë²„ ë¡œê·¸ í™•ì¸
ğŸš€ ì‹¤ì‹œê°„ í…ŒìŠ¤íŠ¸
text
1. ì—°ê²° â†’ onConnect ì½œë°± í™•ì¸
2. [ì˜¤ë¥˜ ì‹œë®¬ë ˆì´ì…˜] â†’ onStompError ì½œë°± í™•ì¸
3. ë¸Œë¼ìš°ì € ì½˜ì†” â†’ STOMP DEBUG ë¡œê·¸ í™•ì¸
4. ì„œë²„ ì¢…ë£Œ â†’ SockJS onclose â†’ ì¬ì—°ê²°
ì´ ì„¤ì •ìœ¼ë¡œ ëª¨ë“  STOMP ì´ë²¤íŠ¸ 100% í•¸ë“¤ë§ ì™„ë£Œ!

ìœ„ì˜ ë‹µë³€ì„ ê¸°ì´ˆë¡œ ê³ ê°ì´ ì²˜ìŒ ì›¹ì±„íŒ…í•  ë•ŒëŠ” ë´‡ê³¼ ì±„íŒ…í•œ í›„ ê³ ê°ì´ í•„ìš”ì‹œ ìƒë‹´ì‚¬ ì—°ê²°ì„ ì‹ ì²­í•˜ê³  ìƒë‹´ì‚¬ë“¤ì´ ì‹ ì²­í•œ ì—°ê²°ì„ ì„ íƒí•˜ê±°ë‚˜ ìë™ìœ¼ë¡œ ì›¹ì±„íŒ… ì‹œìŠ¤í…œì— ë¡œê·¸ì¸í•œ ìƒë‹´ì‚¬ì—ê²Œ ì‹œìŠ¤í…œì´ ìë™ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ë¡œì§ì„ ì¶©ë¶„í•œ ì„¤ëª…ê³¼ í•¨ê»˜ ì½”ë“œë¥¼ ì‘ì„±í•´ì¤˜
ì›¹ì±„íŒ… ë´‡ â†’ ìƒë‹´ì‚¬ ìë™/ìˆ˜ë™ ì—°ê²° ì‹œìŠ¤í…œ ì™„ì „ êµ¬í˜„
ğŸ¯ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ë° í”Œë¡œìš°
text
[ê³ ê°] â”€â”€ ë´‡ì±„íŒ… â”€â”€> [ë´‡] â”€â”€ ìƒë‹´ìš”ì²­ â”€â”€> [Redis Queue] â”€â”€> [ìƒë‹´ì‚¬ë“¤]
  â”‚                    â”‚                        â”‚
  â””â”€ STOMP /bot/chat â”€â”€â”¼â”€ Redis "consult:queue" â”€â”¼â”€ STOMP /topic/consult/request
                         â”‚                        â”‚
                    [ìƒë‹´ì‚¬A] [ìƒë‹´ì‚¬B] â† ìë™/ìˆ˜ë™ ì„ íƒ
1. ë°ì´í„° ëª¨ë¸ (DTO)
java
// ìƒë‹´ ìš”ì²­ DTO
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ConsultRequest {
    private String requestId;
    private String customerId;
    private String customerName;
    private String issueCategory;
    private String message;
    private LocalDateTime requestedAt;
    private String status; // "waiting", "assigned", "closed"
    
    public static ConsultRequest create(String customerId, String category, String message) {
        return new ConsultRequest(
            UUID.randomUUID().toString(),
            customerId,
            "ê³ ê°" + customerId,
            category,
            message,
            LocalDateTime.now(),
            "waiting"
        );
    }
}

// ìƒë‹´ ì—°ê²° ì‘ë‹µ
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ConsultResponse {
    private String requestId;
    private String agentId;
    private boolean accepted;
    private String message;
}
2. RedisConfig (ìƒë‹´ í ì „ìš©)
java
@Configuration
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        // ... ê¸°ì¡´ ì„¤ì •
    }
    
    // ğŸ”¥ ìƒë‹´ ìš”ì²­ í ì „ìš© í† í”½
    @Bean
    public ChannelTopic consultQueueTopic() {
        return new ChannelTopic("consult:queue");
    }
    
    @Bean
    public RedisMessageListenerContainer consultListenerContainer(
            RedisConnectionFactory connectionFactory, ChannelTopic consultQueueTopic) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.addMessageListener(new ConsultQueueSubscriber(), consultQueueTopic);
        return container;
    }
}
3. ë´‡ ì„œë¹„ìŠ¤ (BotService)
java
@Service
@Slf4j
@RequiredArgsConstructor
public class BotService {
    
    private final RedisPublisher redisPublisher;
    private final SimpMessagingTemplate messagingTemplate;
    
    // ê³ ê°ì´ "ìƒë‹´ì‚¬ ì—°ê²°" ìš”ì²­ ì‹œ
    public void requestConsult(ConsultRequest request) {
        log.info("ìƒë‹´ ìš”ì²­ ì ‘ìˆ˜: {}", request.getRequestId());
        
        // 1. Redis íì— ìƒë‹´ ìš”ì²­ ë°œí–‰
        redisPublisher.publish("consult:queue", request);
        
        // 2. ê³ ê°ì—ê²Œ ëŒ€ê¸° ë©”ì‹œì§€ ì „ì†¡
        messagingTemplate.convertAndSendToUser(
            request.getCustomerId(), 
            "/queue/consult/status", 
            Map.of("requestId", request.getRequestId(), "status", "waiting")
        );
        
        log.info("ìƒë‹´ì‚¬ë“¤ì—ê²Œ ì•Œë¦¼ ì „ì†¡: {}", request.getRequestId());
    }
    
    // ìƒë‹´ì‚¬ ì—°ê²° ì™„ë£Œ ì•Œë¦¼
    public void notifyConsultAssigned(String requestId, String agentId) {
        // Redisì—ì„œ ìš”ì²­ ì •ë³´ ì¡°íšŒ (ê°„ì†Œí™”)
        messagingTemplate.convertAndSend("/topic/consult/assigned/" + requestId, 
            Map.of("agentId", agentId, "status", "connected"));
    }
}
4. ìƒë‹´ í Subscriber (ConsultQueueSubscriber)
java
@Component
@Slf4j
@RequiredArgsConstructor
public class ConsultQueueSubscriber implements MessageListener {
    
    private final SimpMessagingTemplate messagingTemplate;
    
    @Override
    public void onMessage(Message message, byte[] pattern) {
        try {
            String payload = new String(message.getBody());
            ConsultRequest request = new ObjectMapper().readValue(payload, ConsultRequest.class);
            
            log.info("ìƒë‹´ í ìˆ˜ì‹ : {} - {}", request.getRequestId(), request.getIssueCategory());
            
            // ğŸ”¥ ëª¨ë“  ìƒë‹´ì‚¬ì—ê²Œ ì‹¤ì‹œê°„ ì•Œë¦¼ (STOMP /topic/consult/request)
            messagingTemplate.convertAndSend("/topic/consult/request", request);
            
        } catch (Exception e) {
            log.error("ìƒë‹´ í ì²˜ë¦¬ ì‹¤íŒ¨", e);
        }
    }
}
5. ìƒë‹´ì‚¬ ì»¨íŠ¸ë¡¤ëŸ¬ (AgentController)
java
@Controller
@RequiredArgsConstructor
@Slf4j
public class AgentController {
    
    private final BotService botService;
    private final RedisTemplate<String, Object> redisTemplate;
    
    // ìƒë‹´ì‚¬ ë¡œê·¸ì¸ (WebSocket ì—°ê²° í›„)
    @MessageMapping("/agent.login")
    public void agentLogin(@Payload Map<String, String> agentInfo, Principal principal) {
        String agentId = principal.getName();
        log.info("{} ìƒë‹´ì‚¬ ë¡œê·¸ì¸", agentId);
        
        // ìƒë‹´ì‚¬ ëª©ë¡ Redisì— ì¶”ê°€ (ì‹¤ì‹œê°„ ì•Œë¦¼ìš©)
        redisTemplate.opsForSet().add("online:agents", agentId);
    }
    
    // ğŸ”¥ ìƒë‹´ì‚¬ ìƒë‹´ ìˆ˜ë½
    @MessageMapping("/agent.accept")
    public void acceptConsult(@Payload ConsultResponse response, Principal principal) {
        String agentId = principal.getName();
        String requestId = response.getRequestId();
        
        log.info("{} ìƒë‹´ì‚¬ {} ìš”ì²­ ìˆ˜ë½", agentId, requestId);
        
        // 1. Redisì—ì„œ ìš”ì²­ ìƒíƒœ ì—…ë°ì´íŠ¸
        redisTemplate.opsForHash().put("consult:" + requestId, "agentId", agentId);
        redisTemplate.opsForHash().put("consult:" + requestId, "status", "assigned");
        
        // 2. ê³ ê°ê³¼ ìƒë‹´ì‚¬ ì—°ê²° ì™„ë£Œ ì•Œë¦¼
        botService.notifyConsultAssigned(requestId, agentId);
        
        // 3. í•´ë‹¹ ë°©ìœ¼ë¡œ 1:1 ì±„íŒ…ë°© ìƒì„±
        createPrivateChatRoom(requestId, response.getCustomerId(), agentId);
    }
    
    // ìƒë‹´ì‚¬ ìƒë‹´ ê±°ì ˆ
    @MessageMapping("/agent.reject")
    public void rejectConsult(@Payload Map<String, String> rejectInfo, Principal principal) {
        String requestId = rejectInfo.get("requestId");
        log.info("{} ìƒë‹´ì‚¬ {} ìš”ì²­ ê±°ì ˆ", principal.getName(), requestId);
        
        // ë‹¤ìŒ ìƒë‹´ì‚¬ì—ê²Œ ì¬ë°°í¬ ë˜ëŠ” ê³ ê°ì—ê²Œ ëŒ€ê¸° ë©”ì‹œì§€
        redisTemplate.opsForHash().put("consult:" + requestId, "status", "rejected");
    }
}
6. ìë™ ë°°ë¶„ ì„œë¹„ìŠ¤ (AutoAssignService)
java
@Service
@RequiredArgsConstructor
@Slf4j
public class AutoAssignService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final SimpMessagingTemplate messagingTemplate;
    private final TaskScheduler taskScheduler;
    
    @PostConstruct
    public void startAutoAssign() {
        // 10ì´ˆë§ˆë‹¤ ëŒ€ê¸°ì¤‘ì¸ ìƒë‹´ ìš”ì²­ í™•ì¸
        taskScheduler.scheduleAtFixedRate(this::assignWaitingConsults, 10000);
    }
    
    private void assignWaitingConsults() {
        // Redisì—ì„œ ëŒ€ê¸°ì¤‘ì¸ ìš”ì²­ ì¡°íšŒ
        Set<String> waitingRequests = redisTemplate.opsForSet().members("waiting:consults");
        
        for (String requestId : waitingRequests) {
            assignToAvailableAgent(requestId);
        }
    }
    
    private void assignToAvailableAgent(String requestId) {
        // ì˜¨ë¼ì¸ ìƒë‹´ì‚¬ ëª©ë¡ ì¡°íšŒ
        Set<String> onlineAgents = redisTemplate.opsForSet().members("online:agents");
        
        if (!onlineAgents.isEmpty()) {
            // ê°€ì¥ ì˜¤ë˜ëœ ìƒë‹´ì‚¬ì—ê²Œ ìë™ ë°°ì • (Round Robin ë˜ëŠ” FIFO)
            String agentId = onlineAgents.iterator().next();
            
            log.info("ìë™ ë°°ì •: {} â†’ {}", requestId, agentId);
            
            // ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ì•Œë¦¼
            redisTemplate.opsForHash().put("consult:" + requestId, "agentId", agentId);
            redisTemplate.opsForSet().remove("waiting:consults", requestId);
            
            messagingTemplate.convertAndSend("/topic/consult/assigned/" + requestId, 
                Map.of("agentId", agentId, "status", "auto_assigned"));
        }
    }
}
7. ê³ ê°/ìƒë‹´ì‚¬ í†µí•© HTML í´ë¼ì´ì–¸íŠ¸
xml
<!DOCTYPE html>
<html>
<head>
    <title>ë´‡ â†’ ìƒë‹´ì‚¬ ì—°ê²° ì‹œìŠ¤í…œ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        .chat-container { max-width: 800px; margin: 0 auto; }
        .mode-selector { text-align: center; margin: 20px 0; }
        .mode-selector button { padding: 10px 20px; margin: 0 10px; }
        .active-mode { background: #007bff; color: white; }
        #chatArea { border: 1px solid #ddd; height: 500px; overflow-y: scroll; padding: 20px; }
        .consult-section { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; }
        button { padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer; }
        .request-btn { background: #28a745; color: white; }
        .accept-btn { background: #17a2b8; color: white; }
        .reject-btn { background: #dc3545; color: white; }
    </style>
</head>
<body>
    <div class="chat-container">
        <h1>ğŸ¤– ì›¹ì±„íŒ…: ë´‡ â†’ ìƒë‹´ì‚¬ ì—°ê²°</h1>
        
        <!-- ëª¨ë“œ ì „í™˜ -->
        <div class="mode-selector">
            <button onclick="setMode('customer')" class="active-mode" id="customerBtn">ğŸ‘¤ ê³ ê° ëª¨ë“œ</button>
            <button onclick="setMode('agent')" id="agentBtn">ğŸ‘¨â€ğŸ’¼ ìƒë‹´ì‚¬ ëª¨ë“œ</button>
        </div>
        
        <!-- ì±„íŒ… ì˜ì—­ -->
        <div id="chatArea"></div>
        
        <!-- ê³ ê° ì…ë ¥ -->
        <div id="customerInput" class="consult-section">
            <input type="text" id="customerMessage" placeholder="ë´‡ì—ê²Œ ì§ˆë¬¸í•˜ì„¸ìš”..." style="width: 70%;">
            <button onclick="sendCustomerMessage()">ì „ì†¡</button>
            <br><br>
            <button class="request-btn" onclick="requestConsult()">ğŸ“ ìƒë‹´ì‚¬ ì—°ê²° ìš”ì²­</button>
            <div id="consultStatus"></div>
        </div>
        
        <!-- ìƒë‹´ì‚¬ íŒ¨ë„ -->
        <div id="agentPanel" class="consult-section" style="display: none;">
            <h3>ëŒ€ê¸°ì¤‘ì¸ ìƒë‹´ ìš”ì²­</h3>
            <div id="pendingRequests"></div>
        </div>
    </div>

    <script>
        let stompClient = null;
        let jwtToken = null;
        let currentMode = 'customer';
        let pendingRequests = [];
        let currentRequestId = null;

        // ëª¨ë“œ ì „í™˜
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('customerBtn').classList.toggle('active-mode', mode === 'customer');
            document.getElementById('agentBtn').classList.toggle('active-mode', mode === 'agent');
            document.getElementById('customerInput').style.display = mode === 'customer' ? 'block' : 'none';
            document.getElementById('agentPanel').style.display = mode === 'agent' ? 'block' : 'none';
        }

        // STOMP ì—°ê²°
        async function connect() {
            jwtToken = await getToken(); // ì´ì „ ì˜ˆì œì—ì„œ êµ¬í˜„
            const socket = new SockJS('http://localhost:8080/ws-chat');
            stompClient = Stomp.over(socket);
            
            stompClient.connect({ Authorization: 'Bearer ' + jwtToken }, frame => {
                console.log('ì—°ê²° ì„±ê³µ');
                
                // ë´‡ ì±„íŒ… êµ¬ë…
                stompClient.subscribe('/topic/chat/bot', message => {
                    addMessage('ğŸ¤– ë´‡', JSON.parse(message.body).message);
                });
                
                // ìƒë‹´ ìš”ì²­ ì•Œë¦¼ (ìƒë‹´ì‚¬)
                stompClient.subscribe('/topic/consult/request', message => {
                    const request = JSON.parse(message.body);
                    handleNewConsultRequest(request);
                });
                
                // ìƒë‹´ ìƒíƒœ ë³€ê²½
                stompClient.subscribe('/user/queue/consult/status', message => {
                    const status = JSON.parse(message.body);
                    updateConsultStatus(status);
                });
            });
        }

        // ê³ ê° ë©”ì‹œì§€ ì „ì†¡ (ë´‡)
        function sendCustomerMessage() {
            const msg = document.getElementById('customerMessage').value;
            stompClient.send('/app/chat.bot', {}, JSON.stringify({
                customerId: 'cust1',
                message: msg
            }));
            document.getElementById('customerMessage').value = '';
        }

        // ğŸ”¥ ìƒë‹´ì‚¬ ì—°ê²° ìš”ì²­
        function requestConsult() {
            const request = {
                customerId: 'cust1',
                issueCategory: 'ê²°ì œë¬¸ì˜',
                message: 'ê²°ì œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
            };
            stompClient.send('/app/consult.request', {}, JSON.stringify(request));
            addMessage('ì‹œìŠ¤í…œ', 'ìƒë‹´ì‚¬ ì—°ê²° ìš”ì²­ ì¤‘...');
            currentRequestId = request.requestId;
        }

        // ìƒë‹´ì‚¬ ìƒˆ ìš”ì²­ ì²˜ë¦¬
        function handleNewConsultRequest(request) {
            pendingRequests.push(request);
            displayPendingRequests();
        }

        // ëŒ€ê¸° ìš”ì²­ UI í‘œì‹œ
        function displayPendingRequests() {
            const container = document.getElementById('pendingRequests');
            container.innerHTML = pendingRequests.map(req => `
                <div style="border: 1px solid #ddd; padding: 10px; margin: 10px 0;">
                    <strong>${req.customerName}</strong> - ${req.issueCategory}
                    <p>${req.message}</p>
                    <button class="accept-btn" onclick="acceptConsult('${req.requestId}')">ìˆ˜ë½</button>
                    <button class="reject-btn" onclick="rejectConsult('${req.requestId}')">ê±°ì ˆ</button>
                </div>
            `).join('');
        }

        // ìƒë‹´ ìˆ˜ë½
        function acceptConsult(requestId) {
            stompClient.send('/app/agent.accept', {}, JSON.stringify({
                requestId: requestId,
                accepted: true
            }));
            addMessage('ì‹œìŠ¤í…œ', `ìƒë‹´ ìš”ì²­ ${requestId} ìˆ˜ë½ë¨`);
        }

        // ìƒë‹´ ê±°ì ˆ
        function rejectConsult(requestId) {
            stompClient.send('/app/agent.reject', {}, JSON.stringify({
                requestId: requestId
            }));
        }

        // ìƒë‹´ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateConsultStatus(status) {
            document.getElementById('consultStatus').innerHTML = `
                <div style="padding: 10px; background: ${status.status === 'connected' ? '#d4edda' : '#fff3cd'};">
                    ìƒë‹´ ìƒíƒœ: ${status.status} ${status.agentId ? `| ìƒë‹´ì‚¬: ${status.agentId}` : ''}
                </div>
            `;
            addMessage('ì‹œìŠ¤í…œ', `ìƒë‹´ ${status.status === 'connected' ? 'ì—°ê²°ë¨' : 'ëŒ€ê¸°ì¤‘'}`);
        }

        function addMessage(sender, message) {
            const chatArea = document.getElementById('chatArea');
            chatArea.innerHTML += `<div><strong>${sender}:</strong> ${message}</div>`;
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // ì´ˆê¸°í™”
        connect();
        setMode('customer');
    </script>
</body>
</html>
8. í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
text
1. ê³ ê° ëª¨ë“œ: "ê²°ì œ ì˜¤ë¥˜" â†’ ë´‡ ì‘ë‹µ â†’ "ìƒë‹´ì‚¬ ì—°ê²° ìš”ì²­" í´ë¦­
2. ìƒë‹´ì‚¬ ëª¨ë“œ: ìƒˆ ìš”ì²­ ì•Œë¦¼ â†’ "ìˆ˜ë½" í´ë¦­  
3. ê³ ê°: "ìƒë‹´ì‚¬ ê¹€íŒ€ì¥ ì—°ê²°ë¨" ë©”ì‹œì§€ ìˆ˜ì‹ 
4. 1:1 ì±„íŒ… ì‹œì‘

ìë™ ë°°ë¶„ í…ŒìŠ¤íŠ¸:
1. ìƒë‹´ì‚¬ ë¯¸ìˆ˜ë½ â†’ 10ì´ˆ í›„ ì‹œìŠ¤í…œì´ ì˜¨ë¼ì¸ ìƒë‹´ì‚¬ì—ê²Œ ìë™ ë°°ì •
ğŸ”¥ í•µì‹¬ í”Œë¡œìš° ìš”ì•½
text
1. ê³ ê°: ë´‡ ì±„íŒ… â†’ "ìƒë‹´ì‚¬ ì—°ê²°" ìš”ì²­
2. Redis: consult:queueì— ìš”ì²­ ë°œí–‰
3. ìƒë‹´ì‚¬: /topic/consult/requestë¡œ ì‹¤ì‹œê°„ ì•Œë¦¼
4. ìƒë‹´ì‚¬: ìˆ˜ë½ â†’ Redis ìƒíƒœ ì—…ë°ì´íŠ¸
5. ê³ ê°/ìƒë‹´ì‚¬: ì—°ê²° ì™„ë£Œ â†’ 1:1 ì±„íŒ…ë°© ìƒì„±
6. ìë™ë°°ë¶„: 10ì´ˆ íƒ€ì„ì•„ì›ƒ â†’ ì˜¨ë¼ì¸ ìƒë‹´ì‚¬ ìë™ ì—°ê²°
ì™„ë²½í•œ ë´‡â†’ìƒë‹´ì‚¬ ì—°ê²° ì‹œìŠ¤í…œ ì™„ì„±! Redis Pub/Subìœ¼ë¡œ ì‹¤ì‹œê°„ì„± ë³´ì¥!

ë´‡ ì„œë¹„ìŠ¤ëŠ” ë‹¤ë¥¸ ì„œë²„ì—ì„œ ì œê³µë˜ë©° ì±„íŒ…ì„œë²„ì—ì„œ ë´‡ ì„œë¹„ìŠ¤ì˜ APIë¥¼ í˜¸ì¶œí•˜ê³  ê·¸ ê²°ê³¼ëŠ” ë´‡ ì„œë¹„ìŠ¤ê°€ ì±— ì„œë¹„ìŠ¤ì˜ íŠ¹ì •í•œ APIë¥¼ í˜¸ì¶œí•˜ì—¬ ë‹µë³€ì„ ì£¼ëŠ” êµ¬ì¡°ì¼ë•Œ, ê³ ê°ì´ ë´‡ ì„œë¹„ìŠ¤ê°€ ì •í™•í•œ ë‹µì„ ì£¼ì§€ ì•ŠëŠ”ë‹¤ íŒë‹¨í•˜ì˜€ì„ ë•Œ ìƒë‹´ì‚¬ ì—°ê²°ì„ ìš”ì²­í•˜ê³  ìƒë‹´ì‚¬ê°€ ìˆ˜ë™ìœ¼ë¡œ ê³ ê° ì—°ê²° ìš”ì²­ì„ ìˆ˜ë½í•˜ì—¬ ì±„íŒ…ì´ ì´ë£¨ì–´ì§€ëŠ” êµ¬ì¡°ë¡œ ë‹¤ì‹œ ì˜ˆì œë¥¼ ì‘ì„±í•˜ê³  ì„¤ëª…ì„ ì¶©ë¶„íˆ ë‹¬ì•„ì¤˜ë´
ì™¸ë¶€ ë´‡ ì„œë¹„ìŠ¤ + ì±„íŒ…ì„œë²„ + ìƒë‹´ì‚¬ ì—°ê²° ì™„ì „ êµ¬í˜„
ğŸ¯ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ (ì™¸ë¶€ ë´‡ ì—°ë™)
text
[ê³ ê°] â”€â”€ WebSocket â”€â”€> [ì±„íŒ…ì„œë²„] â”€â”€ HTTP API â”€â”€> [ì™¸ë¶€ ë´‡ì„œë²„]
  â†‘                           â†“                           â†‘
  â”‚                    Redis í                   ë´‡ ì‘ë‹µ API
  â””â”€â”€â”€â”€ ìƒë‹´ìš”ì²­ â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€ ìƒë‹´ì‚¬ ì•Œë¦¼ â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    [ìƒë‹´ì‚¬1] [ìƒë‹´ì‚¬2] (ìˆ˜ë™ ìˆ˜ë½)
1. ìš”ì²­/ì‘ë‹µ DTO
java
// ê³ ê° â†’ ì±„íŒ…ì„œë²„ â†’ ë´‡ì„œë²„ ìš”ì²­
@Data
@AllArgsConstructor
@NoArgsConstructor
public class BotRequest {
    private String sessionId;
    private String customerId;
    private String message;
    private String roomId = "bot-room"; // ê¸°ë³¸ ë´‡ ì±„íŒ…ë°©
}

// ë´‡ì„œë²„ â†’ ì±„íŒ…ì„œë²„ ì‘ë‹µ (ì›¹í›… í˜•íƒœ)
@Data
@AllArgsConstructor
@NoArgsConstructor
public class BotResponse {
    private String sessionId;
    private String customerId;
    private String botMessage;
    private boolean needHuman; // ìƒë‹´ì‚¬ í•„ìš” ì—¬ë¶€
    private String category;   // ìƒë‹´ ì¹´í…Œê³ ë¦¬
}

// ìƒë‹´ ìš”ì²­
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ConsultRequest {
    private String requestId;
    private String sessionId;
    private String customerId;
    private String customerName;
    private String category;
    private String lastBotMessage;
    private LocalDateTime requestedAt;
    private String status = "waiting";
}
2. ì±„íŒ…ì„œë²„ BotController (ì™¸ë¶€ ë´‡ API ì—°ë™)
java
@RestController
@RequestMapping("/api/bot")
@RequiredArgsConstructor
@Slf4j
public class BotController {
    
    private final RestTemplate restTemplate;
    private final BotService botService;
    private final SimpMessagingTemplate messagingTemplate;
    
    // ğŸ”¥ ê³ ê° ë©”ì‹œì§€ â†’ ì™¸ë¶€ ë´‡ API í˜¸ì¶œ
    @PostMapping("/message")
    public ResponseEntity<String> sendToBot(@RequestBody BotRequest request) {
        log.info("ë´‡ ìš”ì²­ ìˆ˜ì‹ : {} - {}", request.getCustomerId(), request.getMessage());
        
        // 1. ë¹„ë™ê¸°ì ìœ¼ë¡œ ì™¸ë¶€ ë´‡ API í˜¸ì¶œ
        CompletableFuture.supplyAsync(() -> {
            try {
                // ì™¸ë¶€ ë´‡ ì„œë²„ í˜¸ì¶œ (ì˜ˆ: http://bot-server:8081/api/chat)
                BotResponse response = restTemplate.postForObject(
                    "http://bot-service:8081/api/chat",
                    request,
                    BotResponse.class
                );
                
                if (response != null) {
                    handleBotResponse(request, response);
                }
                return "OK";
            } catch (Exception e) {
                log.error("ë´‡ API í˜¸ì¶œ ì‹¤íŒ¨", e);
                // ë´‡ ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ ì‘ë‹µ
                handleBotError(request);
                return "ERROR";
            }
        });
        
        return ResponseEntity.ok("ìš”ì²­ ì ‘ìˆ˜ë¨");
    }
    
    // ğŸ”¥ ë´‡ì„œë²„ â†’ ì±„íŒ…ì„œë²„ ì›¹í›… (ë´‡ ì‘ë‹µ ìˆ˜ì‹ )
    @PostMapping("/webhook")
    public ResponseEntity<String> botWebhook(@RequestBody BotResponse response) {
        log.info("ë´‡ ì›¹í›… ìˆ˜ì‹ : {}", response.getSessionId());
        
        // ê³ ê°ì—ê²Œ ë´‡ ì‘ë‹µ ì „ì†¡
        messagingTemplate.convertAndSendToUser(
            response.getCustomerId(),
            "/queue/bot/response",
            response
        );
        
        return ResponseEntity.ok("OK");
    }
    
    private void handleBotResponse(BotRequest request, BotResponse response) {
        // ë´‡ ì‘ë‹µì„ ê³ ê°ì—ê²Œ STOMPìœ¼ë¡œ ì „ì†¡
        messagingTemplate.convertAndSendToUser(
            request.getCustomerId(),
            "/queue/bot/response",
            response
        );
        
        // ìƒë‹´ì‚¬ í•„ìš” ì‹œ ìë™ ìš”ì²­
        if (Boolean.TRUE.equals(response.getNeedHuman())) {
            botService.requestConsultAutomatically(request, response);
        }
    }
    
    private void handleBotError(BotRequest request) {
        BotResponse errorResponse = new BotResponse();
        errorResponse.setSessionId(request.getSessionId());
        errorResponse.setCustomerId(request.getCustomerId());
        errorResponse.setBotMessage("ì£„ì†¡í•©ë‹ˆë‹¤. ë´‡ ì„œë¹„ìŠ¤ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ìƒë‹´ì‚¬ ì—°ê²°ì„ ìš”ì²­í•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
        errorResponse.setNeedHuman(true);
        
        messagingTemplate.convertAndSendToUser(
            request.getCustomerId(),
            "/queue/bot/response",
            errorResponse
        );
    }
}
3. BotService (ìƒë‹´ ì—°ê²° ë¡œì§)
java
@Service
@RequiredArgsConstructor
@Slf4j
public class BotService {
    
    private final RedisPublisher redisPublisher;
    private final SimpMessagingTemplate messagingTemplate;
    private final RedisTemplate<String, Object> redisTemplate;
    
    // ê³ ê°ì´ ì§ì ‘ ìƒë‹´ ìš”ì²­ ë˜ëŠ” ë´‡ì´ ìƒë‹´ í•„ìš” íŒë‹¨
    public void requestConsult(String sessionId, String customerId, String category, String reason) {
        ConsultRequest request = ConsultRequest.builder()
            .requestId(UUID.randomUUID().toString())
            .sessionId(sessionId)
            .customerId(customerId)
            .customerName("ê³ ê°" + customerId.substring(5))
            .category(category)
            .lastBotMessage(reason)
            .requestedAt(LocalDateTime.now())
            .build();
        
        // Redis ìƒë‹´ íì— ë°œí–‰
        redisPublisher.publish("consult:queue", request);
        
        // Redis ëŒ€ê¸° ëª©ë¡ ì¶”ê°€
        redisTemplate.opsForSet().add("waiting:consults", request.getRequestId());
        
        // ê³ ê°ì—ê²Œ ëŒ€ê¸° ìƒíƒœ ì „ì†¡
        messagingTemplate.convertAndSendToUser(customerId, "/queue/consult/status", 
            Map.of("requestId", request.getRequestId(), "status", "waiting"));
        
        log.info("ìƒë‹´ ìš”ì²­ ìƒì„±: {} ({})", request.getRequestId(), customerId);
    }
    
    // ë´‡ì´ ìë™ìœ¼ë¡œ ìƒë‹´ ìš”ì²­
    public void requestConsultAutomatically(BotRequest botRequest, BotResponse botResponse) {
        requestConsult(
            botRequest.getSessionId(),
            botRequest.getCustomerId(),
            botResponse.getCategory(),
            "ë´‡ì´ í•´ê²° ëª»í•¨"
        );
    }
}
4. ìƒë‹´ì‚¬ ì»¨íŠ¸ë¡¤ëŸ¬ (ìˆ˜ë™ ìˆ˜ë½)
java
@Controller
@RequiredArgsConstructor
@Slf4j
public class AgentController {
    
    private final BotService botService;
    private final RedisTemplate<String, Object> redisTemplate;
    private final SimpMessagingTemplate messagingTemplate;
    
    // ìƒë‹´ì‚¬ ë¡œê·¸ì¸
    @MessageMapping("/agent.login")
    public void agentLogin(@Payload Map<String, String> agentInfo, Principal principal) {
        String agentId = principal.getName();
        redisTemplate.opsForSet().add("online:agents", agentId);
        log.info("{} ìƒë‹´ì‚¬ ì˜¨ë¼ì¸", agentId);
    }
    
    // ğŸ”¥ ìƒë‹´ì‚¬ ìƒë‹´ ìˆ˜ë½ (í•µì‹¬!)
    @MessageMapping("/agent.accept")
    public void acceptConsult(@Payload Map<String, Object> acceptData, Principal principal) {
        String agentId = principal.getName();
        String requestId = (String) acceptData.get("requestId");
        String sessionId = (String) acceptData.get("sessionId");
        
        log.info("{} ìƒë‹´ì‚¬ {} ìš”ì²­ ìˆ˜ë½", agentId, requestId);
        
        // 1. Redis ìƒíƒœ ì—…ë°ì´íŠ¸
        redisTemplate.opsForHash().put("consult:" + requestId, "agentId", agentId);
        redisTemplate.opsForHash().put("consult:" + requestId, "status", "assigned");
        redisTemplate.opsForSet().remove("waiting:consults", requestId);
        
        // 2. ê³ ê°ê³¼ ìƒë‹´ì‚¬ ì—°ê²° ì™„ë£Œ ì•Œë¦¼
        Map<String, Object> result = Map.of(
            "requestId", requestId,
            "agentId", agentId,
            "status", "connected"
        );
        
        // ê³ ê°ì—ê²Œ
        messagingTemplate.convertAndSendToUser(
            (String) acceptData.get("customerId"),
            "/queue/consult/status",
            result
        );
        
        // ëª¨ë“  ìƒë‹´ì‚¬ì—ê²Œ (ë‹¤ë¥¸ ìƒë‹´ì‚¬ ìš”ì²­ ì·¨ì†Œ ì•Œë¦¼)
        messagingTemplate.convertAndSend("/topic/consult/canceled/" + requestId, result);
        
        // 3. 1:1 ì±„íŒ…ë°© ìƒì„±
        createPrivateChatRoom(sessionId, (String) acceptData.get("customerId"), agentId);
    }
}
5. í´ë¼ì´ì–¸íŠ¸ HTML (ê³ ê° + ìƒë‹´ì‚¬ í†µí•©)
xml
<!DOCTYPE html>
<html>
<head>
    <title>ë´‡ â†’ ìƒë‹´ì‚¬ ì—°ê²° (ì™¸ë¶€ ë´‡ ì—°ë™)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
</head>
<body>
    <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
        <h1>ğŸ¤– ì™¸ë¶€ ë´‡ â†’ ìƒë‹´ì‚¬ ì—°ê²° ì‹œìŠ¤í…œ</h1>
        
        <!-- ëª¨ë“œ ì„ íƒ -->
        <div style="text-align: center; margin: 20px 0;">
            <button onclick="setMode('customer')" id="customerBtn" class="mode-btn active">ğŸ‘¤ ê³ ê°</button>
            <button onclick="setMode('agent')" id="agentBtn" class="mode-btn">ğŸ‘¨â€ğŸ’¼ ìƒë‹´ì‚¬</button>
        </div>
        
        <!-- ì±„íŒ… ì˜ì—­ -->
        <div id="chatArea" style="border: 1px solid #ddd; height: 400px; overflow-y: scroll; padding: 15px;"></div>
        
        <!-- ê³ ê° ì…ë ¥ -->
        <div id="customerSection">
            <div style="margin: 15px 0;">
                <input id="customerMsg" placeholder="ë´‡ì—ê²Œ ì§ˆë¬¸..." style="width: 70%; padding: 10px;">
                <button onclick="sendToBot()">ì „ì†¡</button>
                <button onclick="requestHuman()" style="background: #ff6b35; color: white;">ğŸ“ ìƒë‹´ì‚¬ ì—°ê²°</button>
            </div>
            <div id="consultStatus"></div>
        </div>
        
        <!-- ìƒë‹´ì‚¬ íŒ¨ë„ -->
        <div id="agentSection" style="display: none;">
            <h3>ğŸ”” ëŒ€ê¸°ì¤‘ ìƒë‹´ ìš”ì²­</h3>
            <div id="pendingRequests"></div>
        </div>
    </div>

    <script>
        let stompClient = null;
        let jwtToken = null;
        let currentMode = 'customer';
        let mySessionId = 'session_' + Date.now();
        let pendingRequests = [];

        // ëª¨ë“œ ì „í™˜
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('customerBtn').classList.toggle('active', mode === 'customer');
            document.getElementById('agentBtn').classList.toggle('active', mode === 'agent');
            document.getElementById('customerSection').style.display = mode === 'customer' ? 'block' : 'none';
            document.getElementById('agentSection').style.display = mode === 'agent' ? 'block' : 'none';
        }

        // STOMP ì—°ê²°
        async function connect() {
            jwtToken = await getToken(); // ë¡œê·¸ì¸ API í˜¸ì¶œ
            
            const socket = new SockJS('http://localhost:8080/ws-chat');
            stompClient = Stomp.over(socket);
            
            stompClient.connect({ Authorization: 'Bearer ' + jwtToken }, frame => {
                console.log('STOMP ì—°ê²° ì„±ê³µ');
                
                // ë´‡ ì‘ë‹µ êµ¬ë…
                stompClient.subscribe('/user/queue/bot/response', msg => {
                    const response = JSON.parse(msg.body);
                    addMessage('ğŸ¤– ë´‡', response.botMessage);
                    
                    // ë´‡ì´ ìƒë‹´ í•„ìš”í•˜ë‹¤ê³  íŒë‹¨
                    if (response.needHuman) {
                        addMessage('ì‹œìŠ¤í…œ', 'ìƒë‹´ì‚¬ ì—°ê²°ì„ ìš”ì²­í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                    }
                });
                
                // ìƒë‹´ ìš”ì²­ ì•Œë¦¼ (ìƒë‹´ì‚¬ìš©)
                stompClient.subscribe('/topic/consult/request', msg => {
                    const request = JSON.parse(msg.body);
                    handleConsultRequest(request);
                });
                
                // ìƒë‹´ ìƒíƒœ ë³€ê²½
                stompClient.subscribe('/user/queue/consult/status', msg => {
                    const status = JSON.parse(msg.body);
                    updateConsultStatus(status);
                });
            });
        }

        // ğŸ”¥ ê³ ê° â†’ ë´‡ì„œë²„ API í˜¸ì¶œ
        async function sendToBot() {
            const message = document.getElementById('customerMsg').value;
            if (!message) return;
            
            // ì±„íŒ…ì„œë²„ì˜ ë´‡ API í˜¸ì¶œ
            await fetch('http://localhost:8080/api/bot/message', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sessionId: mySessionId,
                    customerId: 'cust_' + Date.now(),
                    message: message
                })
            });
            
            document.getElementById('customerMsg').value = '';
            addMessage('ë‚˜', message);
        }

        // ğŸ”¥ ê³ ê° ìƒë‹´ì‚¬ ì—°ê²° ìš”ì²­
        function requestHuman() {
            stompClient.send('/app/consult.request', {}, JSON.stringify({
                sessionId: mySessionId,
                customerId: 'cust_' + Date.now(),
                category: 'ì¼ë°˜ë¬¸ì˜',
                reason: 'ë´‡ ì‘ë‹µ ë¶ˆë§Œì¡±'
            }));
            addMessage('ì‹œìŠ¤í…œ', 'ìƒë‹´ì‚¬ ì—°ê²° ìš”ì²­ ì¤‘ì…ë‹ˆë‹¤...');
        }

        // ìƒë‹´ì‚¬ ìƒˆ ìš”ì²­ ì²˜ë¦¬
        function handleConsultRequest(request) {
            pendingRequests.push(request);
            displayPendingRequests();
        }

        function displayPendingRequests() {
            const container = document.getElementById('pendingRequests');
            container.innerHTML = pendingRequests.map(req => `
                <div style="border: 1px solid #007bff; padding: 15px; margin: 10px 0; border-radius: 8px;">
                    <h4>${req.customerName} (${req.category})</h4>
                    <p>${req.lastBotMessage}</p>
                    <button onclick="acceptRequest('${req.requestId}')" 
                            style="background: #28a745; color: white;">âœ… ìˆ˜ë½</button>
                    <button onclick="rejectRequest('${req.requestId}')" 
                            style="background: #dc3545; color: white;">âŒ ê±°ì ˆ</button>
                </div>
            `).join('');
        }

        function acceptRequest(requestId) {
            stompClient.send('/app/agent.accept', {}, JSON.stringify({
                requestId: requestId,
                sessionId: mySessionId,
                customerId: pendingRequests.find(r => r.requestId === requestId)?.customerId
            }));
        }

        function rejectRequest(requestId) {
            stompClient.send('/app/agent.reject', {}, JSON.stringify({ requestId }));
            pendingRequests = pendingRequests.filter(r => r.requestId !== requestId);
            displayPendingRequests();
        }

        function updateConsultStatus(status) {
            document.getElementById('consultStatus').innerHTML = `
                <div style="padding: 10px; background: #d4edda; border-radius: 5px; margin: 10px 0;">
                    ìƒë‹´ì‚¬ ${status.agentId || 'ëŒ€ê¸°ì¤‘'} ì—°ê²°ë¨
                </div>
            `;
        }

        function addMessage(sender, message) {
            const chatArea = document.getElementById('chatArea');
            chatArea.innerHTML += `
                <div style="margin: 5px 0; padding: 8px;">
                    <strong style="color: ${sender === 'ë‚˜' ? '#007bff' : '#28a745'}">${sender}:</strong> 
                    ${message}
                </div>
            `;
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // ì´ˆê¸°í™”
        connect();
    </script>
</body>
</html>
6. ì™¸ë¶€ ë´‡ì„œë²„ ì˜ˆì œ (Node.js)
javascript
// bot-server.js (ë³„ë„ ì„œë²„ 8081 í¬íŠ¸)
const express = require('express');
const axios = require('axios');
app = express();

app.use(express.json());

app.post('/api/chat', async (req, res) => {
    const { sessionId, customerId, message } = req.body;
    
    // ê°„ë‹¨í•œ ë´‡ ë¡œì§ (ì‹¤ì œë¡œëŠ” AI ëª¨ë¸ í˜¸ì¶œ)
    let botResponse = { sessionId, customerId };
    
    if (message.includes('í™˜ë¶ˆ')) {
        botResponse.botMessage = 'í™˜ë¶ˆì€ ë§ˆì´í˜ì´ì§€ì—ì„œ ê°€ëŠ¥í•©ë‹ˆë‹¤.';
        botResponse.needHuman = false;
    } else if (message.includes('ê²°ì œì˜¤ë¥˜')) {
        botResponse.botMessage = 'ê²°ì œ ì˜¤ë¥˜ëŠ” ìƒë‹´ì‚¬ê°€ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤.';
        botResponse.needHuman = true;
        botResponse.category = 'ê²°ì œ';
    } else {
        botResponse.botMessage = `ë„¤, "${message}"ì— ëŒ€í•´ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.`;
        botResponse.needHuman = false;
    }
    
    // ì±„íŒ…ì„œë²„ë¡œ ì›¹í›… í˜¸ì¶œ
    await axios.post('http://localhost:8080/api/bot/webhook', botResponse);
    
    res.json(botResponse);
});

app.listen(8081, () => console.log('Bot Server running on 8081'));
ğŸ”¥ í”Œë¡œìš° ìƒì„¸ ì„¤ëª…
text
1. ê³ ê°: "ê²°ì œ ì˜¤ë¥˜" ì…ë ¥
   â†“ ì±„íŒ…ì„œë²„ /api/bot/message â†’ ë´‡ì„œë²„ /api/chat
   
2. ë´‡ì„œë²„: needHuman=true íŒë‹¨
   â†“ ì±„íŒ…ì„œë²„ /api/bot/webhook í˜¸ì¶œ
   
3. ì±„íŒ…ì„œë²„: Redis consult:queue ë°œí–‰
   â†“ ëª¨ë“  ìƒë‹´ì‚¬ /topic/consult/request ìˆ˜ì‹ 
   
4. ìƒë‹´ì‚¬A: ìˆ˜ë½ ë²„íŠ¼ í´ë¦­
   â†“ Redis ìƒíƒœ ì—…ë°ì´íŠ¸ â†’ ê³ ê°/ìƒë‹´ì‚¬ ì—°ê²° ì™„ë£Œ
   
5. 1:1 ì±„íŒ…ë°© ìë™ ìƒì„±
ì™¸ë¶€ ë´‡ ì™„ë²½ ì—°ë™ + ìƒë‹´ì‚¬ ìˆ˜ë™ ì—°ê²° ì‹œìŠ¤í…œ ì™„ì„±!